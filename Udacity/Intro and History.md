Software Engineer

The importance of software engineer. Computer: programming device. 

##### Software Engineer: 
discipline that complicates software development. 

2 aspects:

- Quality
- The entire life cycle

Software Development is now Distributed. 

Remember when Bevos used to say: 
```
The development process needs to be distributed, all teams must be ready to expose their programming interfaces that are well documented as well as well-engineered. Communication between teams is a must. 
```

Why is it so difficult to build good software.
Discipline:

- Methodologies
- Techniques
- Tools

The software Crisis:
- Rising demand for software: in phones, in cars.
- Everything was mostly hardware to software. Growth in NASA's software demand grows exponentially.
- Increase of product complexity. It increases complex expentially to. 
- Slow productivity growth

|Programming Effort | Software Engineering Effort|
|:-----:|:------:|
| Class Exercise, Small Project, Term Project | Word Processor, OS, Distributed Systems. 

## Evidence of Software Crisis
Davis in 1990 studied that: There are a large proportion of software not delivered or successful used which corresponds to 5M dollars/7Mil. 
NATO's Software Engineering in Jan 1969 is the start.

## Software Development
Starts: An abstract idea (e.g. Customer's) .
Ends: Concrete system. 

Software Process comes to the rescue: This breaks down the development into smaller steps that can be easily handled. 

Properties:
- Systematic
- Formal

There are multiple processes:
1. Waterfall: goes from one way to another
1. Evolutionary prototyping: start with an initial prototype and gets reviews gradually
1. Unified Process: integrates UML
1. Agile: sacrifice disciplines to accomadate changes.

Study has shown that on average professional SE writes 50-100 loc a day because writing code is not the only thing they do.

## Software Phrases:
1. Requirement Engineering: Gather requirements from Customers/stakeholders to understand the kind of system
1. Design: high level structure of our systems.
1. Implementation: Implement the design
1. Verification/Validation (Testing): Make sure the code behave as intended.
1. Maintainance: Add functionality, debug. 

## Tools 
Fundamental to the productivity of the process.
We need tools to confidently moves from developer's productivity to accomodate large size complexity.
E.g.: 
- Development from punch cards in the past to IDEs.
- Language: Assembly -> High level languages
- Debugging Print lines -> debuggers.
- 
Examples tools are:
1. IDE
1. git
1. Coverage and verification for testing